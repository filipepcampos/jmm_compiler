PARSER_PACKAGE=pt.up.fe.comp;
PARSER_CLASS=JmmGrammarParser;
TOKENS_ARE_NODES=false;
SMART_NODE_CREATION=false;

SKIP : " " | "\t" | "\r" | "\n" | < "//"(~["\n","\t","\r"])* > | < "/*" (~["*"])* "*" (~["*","/"] (~["*"])* "*" | "*")* "/" >;


TOKEN :
	< PLUS : "+" > |
	< MINUS : "-" > |
	< TIMES : "*" > |
	< DIVIDE : "/" > |
	< OPEN_PAREN : "(" > |
	< CLOSE_PAREN : ")" > |
	< AND : "&&" > |
	< LOWER : "<" > |
	< OPEN_SQUARE_PAREN : "[" > |
	< CLOSE_SQUARE_PAREN : "]" > |
	< OPEN_CURLY_BRAC : "{" > |
	< CLOSE_CURLY_BRAC : "}" > |
	< IMPORT : "import" > |
	< FULL_STOP : "." > |
	< EQUALS : "=" > |
	< EXCLAMATION_MARK : "!" > |
	< COMMA : "," > |
	< SEMICOLON : ";" > |
	< LENGTH : "length" > |
	< PUBLIC : "public" > |
	< TRUE : "true" > |
	< FALSE : "false" > |
	< THIS : "this" > |
	< NEW : "new" > |
	< INT : "int" > |
	< CLASS : "class" > |
	< EXTENDS : "extends" > |
	< RETURN : "return" > |
	< STATIC : "static" > |
	< VOID : "void" > |
	< MAIN : "main" > |
	< STRING : "String" > |
	< BOOLEAN : "boolean" > |
	< IF : "if" > |
	< ELSE : "else" > |
	< WHILE : "while" > | 
	< INTEGER : (["0" - "9"])+ > |
	< BINARY : "0b"(["0" - "1"])+ > |
	< OCT : "0"(["0" - "7"])+ > |
	< HEX : "0x"(["0" - "9", "A" - "F", "a" - "f"])+ > |
	< IDENTIFIER : (["A"-"Z", "a"-"z"] | "_" | "$")(["A"-"Z", "a"-"z", "0"-"9"] | "_" | "$")* >
;	

Start : Program <EOF> ;

Program : ImportDeclaration ClassDeclaration ;

ImportDeclaration :
	(
		< IMPORT > 
		< IDENTIFIER > 
		(< FULL_STOP > < IDENTIFIER >)* 
		< SEMICOLON >
	)*
;

ClassDeclaration :
	< CLASS > < IDENTIFIER > (< EXTENDS > < IDENTIFIER >)? 
	< OPEN_CURLY_BRAC >
		(VarDeclaration)* 
		(MethodDeclaration)* 
	< CLOSE_CURLY_BRAC >
;

VarDeclaration : Type < IDENTIFIER > < SEMICOLON > ;

MethodDeclaration :
	SCAN 2
	(MainMethodDeclaration) | (InstanceMethodDeclaration) 
;

MainMethodDeclaration :
	< PUBLIC > < STATIC > < VOID > < MAIN > < OPEN_PAREN > 
	< STRING > < OPEN_SQUARE_PAREN > < CLOSE_SQUARE_PAREN > < IDENTIFIER >
	< CLOSE_PAREN >
	< OPEN_CURLY_BRAC >
		( SCAN 2 (VarDeclaration) )*
		( Statement )*
	< CLOSE_CURLY_BRAC >
;

InstanceMethodDeclaration :
	< PUBLIC > Type < IDENTIFIER > 
	< OPEN_PAREN > ( Type < IDENTIFIER > (< COMMA > Type < IDENTIFIER > )* )?  < CLOSE_PAREN > 
	< OPEN_CURLY_BRAC >
		( SCAN 2 (VarDeclaration) )*
		( Statement )*
		< RETURN > AndExpression < SEMICOLON >
	< CLOSE_CURLY_BRAC >
;


Type :
	<INT> (<OPEN_SQUARE_PAREN> <CLOSE_SQUARE_PAREN>)? |
	<BOOLEAN> |
	<STRING> |
	<IDENTIFIER>
;

Statement :
	<OPEN_CURLY_BRAC> (Statement)* <CLOSE_CURLY_BRAC> |
	<IF> <OPEN_PAREN> AndExpression <CLOSE_PAREN> Statement <ELSE> Statement |
	<WHILE> <OPEN_PAREN> AndExpression <CLOSE_PAREN> Statement |
	SCAN 2 (<IDENTIFIER> <EQUALS>) AndExpression <SEMICOLON> |
	SCAN 2 (<IDENTIFIER> <OPEN_SQUARE_PAREN>) AndExpression <CLOSE_SQUARE_PAREN> <EQUALS> AndExpression <SEMICOLON> |
	AndExpression <SEMICOLON>
;

AndExpression #void :
	LowerExpression ( <AND> LowerExpression #BinaryOp(2) )*
;

LowerExpression #void :
	AdditiveExpression ( <LOWER> AdditiveExpression #BinaryOp(2) )*
;

AdditiveExpression #void :
	MultiplicativeExpression (
		(<PLUS> MultiplicativeExpression { jjtThis.put("op", "ADD"); }) #BinaryOp(2) |
		(<MINUS> MultiplicativeExpression { jjtThis.put("op", "SUB"); }) #BinaryOp(2)
	)*
;

MultiplicativeExpression #void :
	NotExpression ( (<TIMES> | <DIVIDE>) NotExpression #BinaryOp(2))*
;

NotExpression #void :
	(<EXCLAMATION_MARK> Expression #UnaryOp(1)) |
	Expression
;

Expression :
	ExpressionFirst (
		<OPEN_SQUARE_PAREN> AndExpression <CLOSE_SQUARE_PAREN> |
		<FULL_STOP> ( <LENGTH> | <IDENTIFIER> <OPEN_PAREN> (AndExpression (<COMMA> AndExpression)*)? <CLOSE_PAREN> )
	)?
;

ExpressionFirst #void :
	IntegerLiteral |
	<TRUE> |
	<FALSE> |
	<IDENTIFIER> |
	<THIS> |
	SCAN 2 (<NEW> <INT>) <OPEN_SQUARE_PAREN> AndExpression <CLOSE_SQUARE_PAREN> |
	<NEW> <IDENTIFIER> <OPEN_PAREN> <CLOSE_PAREN> |
	<OPEN_PAREN> AndExpression <CLOSE_PAREN>
;

IntegerLiteral :
	< INTEGER > |
	< BINARY > |
	< OCT > |
	< HEX >
;

// Injections for the implementation of JmmNode
// Since this is injected into BaseNode, it affects only non-terminals
INJECT BaseNode :
	import pt.up.fe.comp.jmm.ast.JmmNode;
	import pt.up.fe.comp.jmm.ast.AJmmNode;
	import pt.up.fe.specs.util.SpecsCollections;
	extends AJmmNode
	{
		@Override
		public List<JmmNode> getChildren() {
			return SpecsCollections.cast(children(), JmmNode.class);
		}

		@Override
		public void add(JmmNode child, int index) {
			if (child instanceof Node) {
				addChild(index, (Node) child);
			} else {
				throw new RuntimeException("Node " + child + " is not a Node.");
			}
		}
}